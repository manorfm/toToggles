package simulations

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import scala.concurrent.duration._
import scala.util.Random
import java.io.File

/**
 * Gatling stress test simulation for ToToggle server.
 * Tests concurrent API calls using different secret keys and toggle paths.
 */
class ToToggleStressSimulation extends Simulation {

  // Configuration
  val baseUrl = System.getProperty("server.url", "http://localhost:3056")
  val maxUsers = Integer.getInteger("max.users", 1000)
  val rampUpDuration = Integer.getInteger("ramp.up.duration", 60).seconds
  val testDuration = Integer.getInteger("test.duration", 300).seconds
  val thinkTime = Integer.getInteger("think.time", 1).seconds

  // Load test data from file generated by setup (simplified approach)
  val testDataFile = new File("gatling-test-data.json")
  
  // Read secret keys from the generated file
  val secretKeys = if (testDataFile.exists()) {
    try {
      val jsonContent = scala.io.Source.fromFile(testDataFile).mkString
      // Extract secret keys with regex - simple but effective
      val secretKeyPattern = "\"secretKey\"\\s*:\\s*\"([^\"]+)\"".r
      val keys = secretKeyPattern.findAllMatchIn(jsonContent).map(_.group(1)).toList
      println(s"ðŸ“ Loaded ${keys.length} secret keys from test data")
      keys
    } catch {
      case e: Exception =>
        println(s"âš ï¸  Error reading test data: ${e.getMessage}")
        List("sk_test_dummy_key_1")
    }
  } else {
    println("âš ï¸  No test data file found, using dummy keys")
    List("sk_test_dummy_key_1")
  }
  
  // Create test data with real secret keys
  val testData = secretKeys.zipWithIndex.map { case (secretKey, i) =>
    Map(
      "name" -> f"stress-test-app-${i+1}%02d",
      "secretKey" -> secretKey,
      "togglePaths" -> List("user", "admin", "payment", "notification", "analytics")
    )
  }.toArray

  // Extract applications data
  val applications = testData.map { app =>
    Map(
      "name" -> app("name").asInstanceOf[String],
      "secretKey" -> app("secretKey").asInstanceOf[String],
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }

  println(s"ðŸ“Š Loaded ${applications.length} applications for stress testing")
  println(s"ðŸŽ¯ Target: $maxUsers concurrent users, ${testDuration.toSeconds}s duration")

  // HTTP configuration
  val httpProtocol = http
    .baseUrl(baseUrl)
    .acceptHeader("application/json")
    .contentTypeHeader("application/json")
    .userAgentHeader("ToToggle-Gatling-StressTest/1.0.0")
    .check(status.is(200))

  // Feeders for test data
  val applicationFeeder = applications.map { app =>
    Map(
      "appName" -> app("name"),
      "secretKey" -> app("secretKey"),
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }.circular

  // Random toggle path selector
  def randomTogglePath(paths: List[String]): String = {
    paths(Random.nextInt(paths.length))
  }

  // Scenarios
  val basicLoadScenario = scenario("Basic Load Test")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    .repeat(50) {
      exec(
        http("Get Toggle Status")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
          .check(responseTimeInMillis.lt(500))
      )
      .pause(thinkTime)
    }

  val highConcurrencyScenario = scenario("High Concurrency Test")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    .repeat(100) {
      exec(
        http("Rapid Toggle Check")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
          .check(responseTimeInMillis.lt(1000))
      )
      .pause(500.milliseconds)
    }

  val mixedWorkloadScenario = scenario("Mixed Workload Test")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      session.set("allPaths", paths)
    }
    .repeat(30) {
      // Check multiple toggles in sequence
      exec { session =>
        val paths = session("allPaths").as[List[String]]
        val randomPath1 = randomTogglePath(paths)
        val randomPath2 = randomTogglePath(paths)
        val randomPath3 = randomTogglePath(paths)
        session
          .set("path1", randomPath1)
          .set("path2", randomPath2)
          .set("path3", randomPath3)
      }
      .exec(
        http("Check Toggle 1")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(100.milliseconds)
      .exec(
        http("Check Toggle 2")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(100.milliseconds)
      .exec(
        http("Check Toggle 3")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(thinkTime)
    }

  val burstTestScenario = scenario("Burst Test")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    // Burst of 20 rapid requests
    .repeat(20) {
      exec(
        http("Burst Request")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
          .check(responseTimeInMillis.lt(2000))
      )
    }
    .pause(5.seconds) // Rest between bursts
    .repeat(10) { // Repeat burst pattern
      repeat(20) {
        exec(
          http("Burst Request")
            .get("/api/toggles")
            .header("X-API-Key", "${secretKey}")
              .check(status.is(200))
        )
      }
      .pause(5.seconds)
    }

  // Load profiles
  setUp(
    // Phase 1: Gradual ramp-up (25% of max users)
    basicLoadScenario.inject(
      rampUsers(maxUsers.intValue() / 4) during rampUpDuration
    ).protocols(httpProtocol),

    // Phase 2: High concurrency test (50% of max users)
    highConcurrencyScenario.inject(
      nothingFor(30.seconds),
      rampUsers(maxUsers.intValue() / 2) during (rampUpDuration / 2)
    ).protocols(httpProtocol),

    // Phase 3: Mixed workload (25% of max users)
    mixedWorkloadScenario.inject(
      nothingFor(60.seconds),
      rampUsers(maxUsers.intValue() / 4) during rampUpDuration
    ).protocols(httpProtocol),

    // Phase 4: Burst test (small number of users)
    burstTestScenario.inject(
      nothingFor(90.seconds),
      rampUsers(maxUsers.intValue() / 10) during (rampUpDuration / 3)
    ).protocols(httpProtocol)

  ).maxDuration(testDuration + 60.seconds) // Extra time for cleanup

  // Assertions for performance validation
  .assertions(
    global.responseTime.max.lt(5000),
    global.responseTime.mean.lt(500),
    global.responseTime.percentile3.lt(1000), // 95th percentile
    global.responseTime.percentile4.lt(2000), // 99th percentile
    global.successfulRequests.percent.gt(99.0), // 99% success rate
    forAll.failedRequests.count.lt(100) // Max 100 failed requests total
  )
}
