package simulations

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import scala.concurrent.duration._
import scala.util.Random
import java.io.File

/**
 * Capacity testing simulation to find the maximum throughput of ToToggle server.
 * Gradually increases load until server starts showing signs of stress.
 */
class CapacityTestSimulation extends Simulation {

  // Configuration
  val baseUrl = System.getProperty("server.url", "http://localhost:3056")
  val startUsers = Integer.getInteger("start.users", 10)
  val maxUsers = Integer.getInteger("max.users", 2000)
  val stepUsers = Integer.getInteger("step.users", 50)
  val stepDuration = Integer.getInteger("step.duration", 30).seconds
  val stableDuration = Integer.getInteger("stable.duration", 60).seconds

  // Load test data from file generated by setup (simplified approach)
  val testDataFile = new File("gatling-test-data.json")
  
  // Read secret keys from the generated file
  val secretKeys = if (testDataFile.exists()) {
    try {
      val jsonContent = scala.io.Source.fromFile(testDataFile).mkString
      // Extract secret keys with regex - simple but effective
      val secretKeyPattern = "\"secretKey\"\\s*:\\s*\"([^\"]+)\"".r
      val keys = secretKeyPattern.findAllMatchIn(jsonContent).map(_.group(1)).toList
      println(s"📁 Loaded ${keys.length} secret keys from test data")
      keys
    } catch {
      case e: Exception =>
        println(s"⚠️  Error reading test data: ${e.getMessage}")
        List("sk_test_dummy_key_1")
    }
  } else {
    println("⚠️  No test data file found, using dummy keys")
    List("sk_test_dummy_key_1")
  }
  
  // Create test data with real secret keys
  val testData = secretKeys.zipWithIndex.map { case (secretKey, i) =>
    Map(
      "name" -> f"stress-test-app-${i+1}%02d",
      "secretKey" -> secretKey,
      "togglePaths" -> List("user", "admin", "payment", "notification", "analytics")
    )
  }.toArray

  val applications = testData.map { app =>
    Map(
      "name" -> app("name").asInstanceOf[String],
      "secretKey" -> app("secretKey").asInstanceOf[String],
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }

  println(s"🔍 Capacity Test: Finding maximum throughput")
  println(s"📈 Load profile: ${startUsers} → ${maxUsers} users (steps of ${stepUsers})")

  // HTTP configuration
  val httpProtocol = http
    .baseUrl(baseUrl)
    .acceptHeader("application/json")
    .contentTypeHeader("application/json")
    .userAgentHeader("ToToggle-Gatling-CapacityTest/1.0.0")

  // Feeders
  val applicationFeeder = applications.map { app =>
    Map(
      "appName" -> app("name"),
      "secretKey" -> app("secretKey"),
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }.circular

  def randomTogglePath(paths: List[String]): String = {
    paths(Random.nextInt(paths.length))
  }

  // Main capacity testing scenario
  val capacityScenario = scenario("Capacity Test")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    .during(stableDuration + stepDuration) {
      exec(
        http("Toggle Check")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(1.second)
    }

  setUp(
    capacityScenario.inject(
      rampUsers(startUsers.intValue()) during (60.seconds),
      incrementUsersPerSec(stepUsers.intValue())
        .times(5)
        .eachLevelLasting(stepDuration)
        .separatedByRampsLasting(10.seconds)
        .startingFrom(startUsers.intValue())
    ).protocols(httpProtocol)
  ).maxDuration((stepDuration.toSeconds * (maxUsers.intValue() - startUsers.intValue()) / stepUsers.intValue() + stableDuration.toSeconds + 60).seconds)

  // Flexible assertions that help identify capacity limits
  .assertions(
    global.responseTime.percentile3.lt(2000), // 95th percentile under 2s
    global.responseTime.mean.lt(1000), // Mean under 1s
    global.successfulRequests.percent.gt(95.0) // 95% success rate
  )
}
