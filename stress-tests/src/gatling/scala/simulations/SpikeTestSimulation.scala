package simulations

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import scala.concurrent.duration._
import scala.util.Random
import java.io.File

/**
 * Spike testing simulation to test how ToToggle server handles sudden traffic spikes.
 * Simulates normal load with periodic massive spikes.
 */
class SpikeTestSimulation extends Simulation {

  // Configuration
  val baseUrl = System.getProperty("server.url", "http://localhost:3056")
  val normalUsers = Integer.getInteger("normal.users", 50)
  val spikeUsers = Integer.getInteger("spike.users", 500)
  val spikeDuration = Integer.getInteger("spike.duration", 30).seconds
  val normalDuration = Integer.getInteger("normal.duration", 60).seconds
  val numberOfSpikes = Integer.getInteger("number.spikes", 5)

  // Load test data from file generated by setup (simplified approach)
  val testDataFile = new File("gatling-test-data.json")
  
  // Read secret keys from the generated file
  val secretKeys = if (testDataFile.exists()) {
    try {
      val jsonContent = scala.io.Source.fromFile(testDataFile).mkString
      // Extract secret keys with regex - simple but effective
      val secretKeyPattern = "\"secretKey\"\\s*:\\s*\"([^\"]+)\"".r
      val keys = secretKeyPattern.findAllMatchIn(jsonContent).map(_.group(1)).toList
      println(s"ðŸ“ Loaded ${keys.length} secret keys from test data")
      keys
    } catch {
      case e: Exception =>
        println(s"âš ï¸  Error reading test data: ${e.getMessage}")
        List("sk_test_dummy_key_1")
    }
  } else {
    println("âš ï¸  No test data file found, using dummy keys")
    List("sk_test_dummy_key_1")
  }
  
  // Create test data with real secret keys
  val testData = secretKeys.zipWithIndex.map { case (secretKey, i) =>
    Map(
      "name" -> f"stress-test-app-${i+1}%02d",
      "secretKey" -> secretKey,
      "togglePaths" -> List("user", "admin", "payment", "notification", "analytics")
    )
  }.toArray

  val applications = testData.map { app =>
    Map(
      "name" -> app("name").asInstanceOf[String],
      "secretKey" -> app("secretKey").asInstanceOf[String],
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }

  println(s"âš¡ Spike Test: ${numberOfSpikes} spikes of ${spikeUsers} users")
  println(s"ðŸ“Š Normal load: ${normalUsers} users, Spike load: ${spikeUsers} users")

  // HTTP configuration
  val httpProtocol = http
    .baseUrl(baseUrl)
    .acceptHeader("application/json")
    .contentTypeHeader("application/json")
    .userAgentHeader("ToToggle-Gatling-SpikeTest/1.0.0")

  // Feeders
  val applicationFeeder = applications.map { app =>
    Map(
      "appName" -> app("name"),
      "secretKey" -> app("secretKey"),
      "togglePaths" -> app("togglePaths").asInstanceOf[List[String]]
    )
  }.circular

  def randomTogglePath(paths: List[String]): String = {
    paths(Random.nextInt(paths.length))
  }

  // Normal load scenario
  val normalLoadScenario = scenario("Normal Load")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    .during((normalDuration + spikeDuration) * numberOfSpikes.toLong + 60.seconds) {
      exec(
        http("Normal Toggle Check")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(2.seconds)
    }

  // Spike load scenario - more aggressive
  val spikeLoadScenario = scenario("Spike Load")
    .feed(applicationFeeder)
    .exec { session =>
      val paths = session("togglePaths").as[List[String]]
      val randomPath = randomTogglePath(paths)
      session.set("togglePath", randomPath)
    }
    .during(spikeDuration) {
      exec(
        http("Spike Toggle Check")
          .get("/api/toggles")
          .header("X-API-Key", "${secretKey}")
          .check(status.is(200))
      )
      .pause(200.milliseconds) // Much more aggressive
    }

  // Create injection pattern with spikes
  val totalDuration = (normalDuration + spikeDuration) * numberOfSpikes.toLong + 60.seconds
  
  // Normal load runs throughout the test
  val normalLoadInjection = rampUsers(normalUsers) during 30.seconds

  // Create spike injections
  val spikeInjections = (0 until numberOfSpikes.intValue()).map { spikeIndex =>
    val spikeStartTime = 30.seconds + (normalDuration + spikeDuration) * spikeIndex.toLong + normalDuration
    
    spikeLoadScenario.inject(
      nothingFor(spikeStartTime),
      rampUsers(spikeUsers) during 10.seconds, // Quick ramp up
      nothingFor(spikeDuration - 10.seconds)
    ).protocols(httpProtocol)
  }

  setUp(
    normalLoadScenario.inject(normalLoadInjection).protocols(httpProtocol) +:
    spikeInjections: _*
  ).maxDuration(totalDuration)

  // Assertions focused on spike recovery
  .assertions(
    global.responseTime.percentile4.lt(5000), // 99th percentile under 5s
    global.responseTime.mean.lt(1500), // Mean under 1.5s (accounting for spikes)
    global.successfulRequests.percent.gt(95.0), // 95% success rate
    details("Normal Toggle Check").responseTime.percentile3.lt(1000), // Normal load should be fast
    details("Spike Toggle Check").responseTime.percentile3.lt(3000) // Spike load can be slower
  )
}
